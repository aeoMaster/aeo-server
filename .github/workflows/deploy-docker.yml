name: Deploy to EC2 with Docker (Zero Downtime)

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on:
      - self-hosted
      - prod

    steps:
      - name: Fix permissions before checkout
        run: |
          # Fix ownership of directories that Docker might have created with root permissions
          sudo chown -R $USER:$USER . 2>/dev/null || true

          echo "‚úÖ Permissions fixed"

      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Setup Docker permissions and verify installation
        run: |
          # Add current user to docker group if not already
          if ! groups | grep -q docker; then
            echo "Adding user to docker group..."
            sudo usermod -aG docker $USER
          fi

          # Fix socket permissions temporarily if needed
          sudo chmod 666 /var/run/docker.sock

          # Verify Docker is working
          docker --version
          docker ps

          # Check if docker-compose is available, if not install it
          if command -v docker-compose &>/dev/null; then
            echo "‚úÖ docker-compose is already installed"
            docker-compose --version
          elif docker compose version &>/dev/null; then
            echo "‚úÖ Docker Compose plugin detected, installing standalone for compatibility"
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            docker-compose --version
          else
            echo "‚ùå Docker Compose not found, installing docker-compose standalone..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            docker-compose --version
          fi

      - name: Create .env file from secrets
        run: |
          cat > .env << EOF
          NODE_ENV=production
          PORT=5000

          # Database (MongoDB Atlas)
          MONGODB_URI=${{ secrets.MONGODB_URI }}

          # Authentication
          AUTH_PROVIDER=${{ secrets.AUTH_PROVIDER }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}

          # Cognito
          COGNITO_REGION=${{ secrets.AWS_REGION }}
          COGNITO_USER_POOL_ID=${{ secrets.AWS_COGNITO_USER_POOL_ID }}
          COGNITO_APP_CLIENT_ID=${{ secrets.AWS_COGNITO_CLIENT_ID }}
          COGNITO_APP_CLIENT_SECRET=${{ secrets.AWS_COGNITO_CLIENT_SECRET }}
          COGNITO_DOMAIN=${{ secrets.AWS_COGNITO_DOMAIN }}
          OAUTH_REDIRECT_URI=${{ secrets.OAUTH_REDIRECT_URI }}
          OAUTH_LOGOUT_REDIRECT_URI=${{ secrets.OAUTH_LOGOUT_REDIRECT_URI }}
          SESSION_SECRET=${{ secrets.SESSION_SECRET }}
          SESSION_TTL_SECONDS=${{ secrets.SESSION_TTL_SECONDS }}
          COOKIE_NAME=${{ secrets.COOKIE_NAME }}
          COOKIE_DOMAIN=${{ secrets.COOKIE_DOMAIN }}

          # OAuth
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI=${{ secrets.GOOGLE_REDIRECT_URI }}
          LINKEDIN_CLIENT_ID=${{ secrets.LINKEDIN_CLIENT_ID }}
          LINKEDIN_CLIENT_SECRET=${{ secrets.LINKEDIN_CLIENT_SECRET }}
          LINKEDIN_REDIRECT_URI=${{ secrets.LINKEDIN_REDIRECT_URI }}

          # Frontend
          CLIENT_URL=${{ secrets.CLIENT_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}

          # API Keys
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          # STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
          # STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}
          # SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}
          # SENDGRID_FROM_EMAIL=${{ secrets.SENDGRID_FROM_EMAIL }}
          # SENDGRID_TEMPLATE_IDS=${{ secrets.SENDGRID_TEMPLATE_IDS }}
          USE_MOCK_EMAIL=${{ secrets.USE_MOCK_EMAIL }}
          PAGESPEED_API_KEY=${{ secrets.PAGESPEED_API_KEY }}

          # AWS
          AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY }}
          AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_COGNITO_USER_POOL_ID=${{ secrets.AWS_COGNITO_USER_POOL_ID }}
          AWS_COGNITO_CLIENT_ID=${{ secrets.AWS_COGNITO_CLIENT_ID }}
          AWS_COGNITO_DOMAIN=${{ secrets.AWS_COGNITO_DOMAIN }}
          AWS_COGNITO_CLIENT_SECRET=${{ secrets.AWS_COGNITO_CLIENT_SECRET }}

          EOF

      - name: Verify .env file
        run: |
          echo "=== Checking .env file exists and has content ==="
          if [ -f .env ]; then
            echo "‚úÖ .env file exists"
            echo "File size: $(wc -c < .env) bytes"
            echo "Number of lines: $(wc -l < .env)"
            echo ""
            echo "=== Environment variables (masked) ==="
            grep -E "^[A-Z_]+=" .env | cut -d= -f1 | sort
          else
            echo "‚ùå .env file not found!"
            exit 1
          fi

      - name: Build new Docker image with cache clearing
        run: |
          echo "üßπ Clearing Docker build cache for fresh build..."

          # Clear Docker build cache to ensure fresh builds
          docker builder prune -f

          # Build with no cache to ensure latest code changes are included
          docker build --no-cache -t aeo-server:${{ github.sha }} .
          docker tag aeo-server:${{ github.sha }} aeo-server:latest

          echo "‚úÖ Docker image built successfully with cache cleared"

      - name: Check current deployment color
        id: check_color
        run: |
          # Check which container is currently running
          if docker ps --format '{{.Names}}' | grep -q "aeo-server-blue"; then
            echo "current_color=blue" >> $GITHUB_OUTPUT
            echo "deploy_color=green" >> $GITHUB_OUTPUT
          else
            echo "current_color=green" >> $GITHUB_OUTPUT
            echo "deploy_color=blue" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to ${{ steps.check_color.outputs.deploy_color }} environment
        run: |
          # Deploy new version to inactive color with force recreate
          docker-compose -f docker-compose.prod.yml up -d --force-recreate app-${{ steps.check_color.outputs.deploy_color }}

      - name: Debug container environment
        run: |
          echo "=== Checking container environment variables ==="
          sleep 3
          docker exec aeo-server-${{ steps.check_color.outputs.deploy_color }} env | grep -E "^(NODE_ENV|PORT|AWS_|AUTH_|MONGODB_|REDIS_)" | sort || true

          echo ""
          echo "=== Container logs (first 30 lines) ==="
          docker logs aeo-server-${{ steps.check_color.outputs.deploy_color }} --tail 30 || true

      - name: Wait for new deployment to be healthy
        run: |
          echo "Waiting for app-${{ steps.check_color.outputs.deploy_color }} to be healthy..."
          for i in {1..30}; do
            if docker exec aeo-server-${{ steps.check_color.outputs.deploy_color }} node -e "require('http').get('http://localhost:5000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" 2>/dev/null; then
              echo "‚úÖ New deployment is healthy!"
              break
            fi
            echo "Attempt $i/30: Waiting for health check..."
            sleep 2
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Health check failed after 30 attempts"
              docker logs aeo-server-${{ steps.check_color.outputs.deploy_color }} --tail 50
              exit 1
            fi
          done

      - name: Reload native Nginx
        run: |
          echo "Reloading native nginx..."
          sudo systemctl reload nginx || echo "‚ö†Ô∏è Nginx reload failed"
          sleep 2
          echo "Nginx reloaded"

      - name: Gracefully stop old deployment
        if: success()
        run: |
          # Give new deployment a moment to fully initialize
          sleep 5

          # Gracefully stop old container
          if [ "${{ steps.check_color.outputs.current_color }}" != "" ]; then
            echo "Stopping old deployment (app-${{ steps.check_color.outputs.current_color }})..."
            docker-compose -f docker-compose.prod.yml stop app-${{ steps.check_color.outputs.current_color }}
            docker-compose -f docker-compose.prod.yml rm -f app-${{ steps.check_color.outputs.current_color }}
          fi

      - name: Verify deployment
        run: |
          echo "=== Deployment Summary ==="
          docker-compose -f docker-compose.prod.yml ps

          echo ""
          echo "=== Health Check (Inside Container) ==="
          # Check the app container from inside
          docker exec aeo-server-${{ steps.check_color.outputs.deploy_color }} node -e "require('http').get('http://localhost:5000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" || exit 1

          echo ""
          echo "=== Health Check (Container Direct Port) ==="
          # Check container on exposed host port
          if [ "${{ steps.check_color.outputs.deploy_color }}" = "blue" ]; then
            curl -f http://localhost:5001/health || exit 1
          else
            curl -f http://localhost:5002/health || exit 1
          fi

          echo ""
          echo "=== Health Check (Native Nginx - HTTP) ==="
          # Check through native nginx
          curl -f http://localhost:80/health || echo "‚ö†Ô∏è HTTP health check failed"

          echo ""
          echo "=== Health Check (Native Nginx - HTTPS) ==="
          # Check through native nginx with SSL
          curl -f -k https://localhost:443/health || echo "‚ö†Ô∏è HTTPS health check failed"

          echo ""
          echo "=== Recent Logs ==="
          docker logs aeo-server-${{ steps.check_color.outputs.deploy_color }} --tail 20

      - name: Cleanup old images and cache
        if: success()
        run: |
          # Remove old unused images (keep last 3)
          docker images aeo-server --format "{{.ID}} {{.Tag}}" | grep -v "latest" | tail -n +4 | awk '{print $1}' | xargs -r docker rmi || true

          # Clean up Docker system to free space
          docker system prune -f

          # Clean up build cache
          docker builder prune -f

          echo "‚úÖ Cleanup completed"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed, rolling back..."
          docker-compose -f docker-compose.prod.yml stop app-${{ steps.check_color.outputs.deploy_color }} || true
          docker-compose -f docker-compose.prod.yml rm -f app-${{ steps.check_color.outputs.deploy_color }} || true

          # Ensure old deployment is still running
          docker-compose -f docker-compose.prod.yml up -d app-${{ steps.check_color.outputs.current_color }} || true

          echo "Rollback completed"
          exit 1

      - name: Send deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment successful to ${{ steps.check_color.outputs.deploy_color }} environment"
          else
            echo "‚ùå Deployment failed, system rolled back to ${{ steps.check_color.outputs.current_color }} environment"
          fi
